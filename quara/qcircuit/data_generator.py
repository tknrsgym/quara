import numpy as np
from typing import List

from quara.settings import Settings


def _random_number_to_data(probdist: np.array, random_number: np.float64) -> int:
    cumulative_sum = 0.0
    for index, prob in enumerate(probdist):
        cumulative_sum += prob
        if random_number < cumulative_sum:
            return index
    return len(probdist) - 1


def generate_data_from_probdist(
    probdist: np.array, data_num: int, seed: int = None, atol: float = None
) -> List[int]:
    """generates random data from a probability distribution.
    
    the data is a sequence (list) of measurement outcomes.
    measurement outcomes are integers.
    0 <= each measurement outcomes < ``len(probdist)``.
    length of the data equals ``data_num``.

    Parameters
    ----------
    probdist : np.array
        a probability distribution used to generate random data.
    data_num : int
        length of the data.
    seed : int, optional
        a seed used to generate random data, by default None.
    atol : float, optional
        the absolute tolerance parameter, uses :func:`~quara.settings.Settings.get_atol` by default.
        checks ``absolute(the sum of probabilities - 1) <= atol`` in this function.

    Returns
    -------
    List[int]
        generated data.

    Raises
    ------
    ValueError
        each probability is not a positive number.
    ValueError
        the sum of probabilities does not equal 1.
    """
    # whether each probability is a positive number.
    for prob in probdist:
        if prob < 0:
            raise ValueError(
                f"each probability must be a positive number. there is {prob} in a probability distribution"
            )

    # whether the sum of probabilities equals 1.
    sum_probdist = np.sum(probdist)
    atol = atol if atol else Settings.get_atol()
    if not np.isclose(sum_probdist, 1, atol=atol, rtol=0.0):
        raise ValueError(
            f"the sum of probabilities must equal 1. the sum of probabilities is {np.sum(probdist)}"
        )

    if seed is not None:
        np.random.seed(seed)

    # generate random numbers. 0 <= rand_val[i] < 1 for all i = 0,..., num_data - 1
    rand_val = np.random.rand(data_num)

    # use np.frompyfunc to apply the function '_random_number_to_data' to np.array
    def curried_random_number_to_data(random_number):
        return _random_number_to_data(probdist, random_number)

    _random_number_to_data_func = np.frompyfunc(curried_random_number_to_data, 1, 1)

    return _random_number_to_data_func(rand_val).tolist()


def generate_dataset_from_list_probdist(
    probdist_list: List[np.array],
    data_num_list: List[int],
    seed_list: List[int] = None,
) -> List[List[int]]:
    """generates random dataset from probability distributions.

    the dataset is a list of data generated by :func:`~quara.qcircuit.data_generator.generate_data_from_probdist`

    Parameters
    ----------
    probdist_list : List[np.array]
        a list of probdist.
    data_num_list : List[int]
        a list of data_num.
    seed_list : List[int], optional
        a list of seed, by default None

    Returns
    -------
    List[List[int]]
        generated dataset.

    Raises
    ------
    ValueError
        the length of ``probdist_list`` does not equal the length of ``data_num_list``.
    ValueError
        ``seed_list`` is not None and the length of ``probdist_list`` does not equal the length of ``seed_list``.
    """
    # whether the length of probdist_list equals the length of data_num_list.
    if len(probdist_list) != len(data_num_list):
        raise ValueError(
            f"the length of probdist_list must equal the length of data_num_list. the length of probdist_list is {len(probdist_list)}. the length of data_num_list is {len(data_num_list)}"
        )

    # whether the length of probdist_list equals the length of seed_list.
    if seed_list is not None:
        if len(probdist_list) != len(seed_list):
            raise ValueError(
                f"the length of probdist_list must equal the length of seed_list. the length of probdist_list is {len(probdist_list)}. the length of data_num_list is {len(seed_list)}"
            )

    dataset = []
    for index, (probdist, data_num) in enumerate(zip(probdist_list, data_num_list)):
        seed = None if seed_list is None else seed_list[index]
        data = generate_data_from_probdist(probdist, data_num, seed)
        dataset.append(data)

    return dataset
